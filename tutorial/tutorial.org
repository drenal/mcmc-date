#+options: ':t *:t -:t ::t <:t H:3 \n:nil ^:nil arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t
#+options: email:nil f:t inline:t num:t p:nil pri:nil prop:nil stat:t tags:t
#+options: tasks:t tex:t timestamp:t title:t toc:nil todo:t |:t
#+title: Dating with constraints
#+subtitle: A detailed tutorial on McmcDate
#+date: January 13, 2023
#+author: Dominik Schrempf
#+email: dominik.schrempf@gmail.com
#+language: en
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 28.2 (Org mode 9.6)

#+latex_class: myArticle
#+latex_class_options: [minted,svg]
#+latex_header:
#+latex_header_extra:
#+description:
#+keywords:
#+subtitle:
#+latex_engraved_theme:
#+latex_compiler: unused; see `org-latex-pdf-process'

#+bibliography: ~/Evolutionary-Biology/Bibliography/bibliography.bib
#+cite_export: biblatex

#+latex: \newcommand*{\mcmcdate}{\mbox{McmcDate}}

#+latex: \begin{abstract}
[[https://github.com/dschrempf/mcmc-date][\mcmcdate{}]] can date a phylogenetic tree with constraints. That is, it can
estimate the ages of ancestral nodes of phylogenetic trees with node age
calibrations, node order constraints, and node braces. \mcmcdate{} is fast
because it approximates the phylogenetic likelihood with a multivariate normal
distribution.

Here, I briefly review the process of dating phylogenetic trees and provide an
example dating analysis of a tree of eukaryotes. I use data from
[cite/t:@Strassert2021] who provide the alignment and node age calibrations from
fossils. Moreover, I use node order constraints from two possible successions of
plastid endosymbiosis events.
#+latex: \end{abstract}

#+begin_center
*This tutorial is a work in progress.*
#+end_center

\tableofcontents

* Definitions
We use the term /(rooted) tree/ to denote a directed acyclic graph with node
labels and branch lengths in which not more than one branch connects any two
nodes. Usually, nodes correspond to (ancestral) species, and branch lengths to
sequence distance or time. We use the term /(rooted) topology/ to denote a
(rooted) tree without information about branch lengths. We put the word /rooted/
into parentheses, because it is sometimes omitted. The root of the tree or
topology is the only node with all branches pointing away to other nodes. The
root is the oldest node. Leaves are extant nodes with a single branch pointing
towards them.

For a given topology, /dating the tree/[fn:1] corresponds to finding branch
lengths for this topology which are measured in absolute time units (for
example, in Million years), and which describe the data in the /best/ way.
/Best/ can mean different things, and we will carefully analyze what /best/
means in our case. Sometimes, all we can do is date a tree with relative time
units (Section\nbsp{}[[id:b1d8692b-db95-42f9-a11d-e492e6debf26]]).

Similarly, we use the term /unrooted tree/ to denote an undirected acyclic graph
with node labels and branch lengths in which not more than one branch connects
any two nodes. Finally, we use the term /unrooted topology/ to denote an
unrooted tree without information about branch lengths. We need unrooted trees
and topologies because we will use reversible substitution models [cite: for a
review, see @Yang2006] to infer unrooted trees with branch lengths measured in
expected number of substitutions per site. Reversible substitution models are
unable to discriminate between the two directions in time.

* Dating a tree
Dating a tree is difficult because we want to estimate branch lengths measured
in absolute time units. However, an alignment only contains information about
distances measured in expected number of substitutions per site. In particular,
it does not contain information about the evolutionary rates nor about the
actual elapsed absolute time units. For a given branch,
\begin{align}
\begin{split}
  d \; & \text{[expected number of substitutions]} = \\
    &r \; \text{[expected number of substitutions per year]} \cdot
    t \; \text{[years]},
\end{split}
\end{align}
where \(d\) is the branch length measured in expected number of substitutions
per site, \(r\) is the evolutionary rate on this branch, and \(t\) is the branch
length measured in absolute time units. The situation is severe because \(r\)
and \(t\) are confounded. If we multiply \(t\) with a positive number \(c\) and
divide \(r\) by the same positive number \(c\), the distance \(d\) stays
constant. Since the likelihood only depends on the distance \(d\) we can not
discriminate between parameter tuples \((t, r)\) and \((t', r')\), where
\begin{align}
  t' &= t \cdot c, \\
  r' &= r / c,
\end{align}
for /any/ \(c \in (0, \infty)\)! This means we need auxiliary data to constrain
the ages of at least some nodes. There are three forms of constraints from
auxiliary data which are explained in the next sections: (a) node age
calibrations, (b) node order constraints, and (c) node braces.
Appendix\nbsp{}[[id:202fc129-8d65-4966-a217-322231ff9c49]] details the
specifications about how auxiliary data is used with \mcmcdate{}.

** Node age calibrations
:PROPERTIES:
:ID:       b1d8692b-db95-42f9-a11d-e492e6debf26
:END:
We call constraints on the ages of internal nodes /node age calibrations/
[cite:@Yang2005]. Without node age calibrations, all dated trees are equally
likely! Since most phylogenetic dating methods are Bayesian, and impose prior
functions on all of their parameters, the values of the posterior function of
different trees still differ in a deceiving way. However, in the absence of node
age calibrations, the differences in the values of the posterior function are
exclusively caused by the chosen prior functions, and not by the information we
have obtained from the data.

Even more, in order to limit the maximum ages of the nodes, we require at least
one node age calibration with a maximum boundary. The closer in terms of
absolute time units the calibrated node with a maximum boundary is to the root,
the better. Ideally, we have a maximum age boundary for the root itself, but
sometimes the root age boundaries are unknown.
Section\nbsp{}[[id:54c61d87-6dbf-48e2-a43e-e788acb0b18f]] provides details on how to
add node age calibrations to your dating analysis with \mcmcdate{}.

I can not repeat this often enough: *Without proper node age calibrations*, and
in particular, *without at least one maximum age boundary*, *dating a tree in
absolute time units is impossible*. Without a single maximum node age boundary,
we can still date the tree using branch lengths measured in /relative time
units/. In particular, we achieve this by fixing the tree height to be 1.0.
\mcmcdate{} automatically falls back to dating in relative time when no maximum
node age boundary is found. If other programs date trees in absolute time units
without a maximum age boundary, do not trust the results!

** Node order constraints
:PROPERTIES:
:ID:       59c21f15-25f3-4e0f-be18-0e94e83a2ac8
:END:
Next to calibrating the absolute ages of nodes, we can also constrain the
relative order of nodes on a tree [cite:@Szollosi2022]. For example, due to
external analyses, we may have detailed knowledge about a horizontal gene
transfer. That is, we do know the exact donor and the recipient branches. In
this case, a direct horizontal gene transfer can only happen, if these branches
coexist for a period of time (Figure\nbsp{}[[fig-transfers]]). If the branches do
not coexist for a period of time but the recipient branch is younger than the
donor branch, the horizontal gene transfer can still happen indirectly through
multiple events. An indirect gene transfer requires an intermediate lineage
carrying the gene. The intermediate lineage has either gone extinct
[cite:@Szollosi2013a], has not been sampled, or has lost the gene. Gene
transfers are impossible if the recipient branch is older than the donor branch.

For example, let the ages of the old and young nodes of the donor and recipient
branches be \(DO\), \(DY\), \(RO\), and \(RY\), respectively. Then, a direct
horizontal gene transfer provides us with two node order constraints,
\begin{align}
  DY < RO, \text{ and } DO > RY,
\end{align}
where \(<\) means /younger than/ and \(>\) means /older than/. If we allow
indirect gene transfers, we only get one node order constraint,
\begin{align}
  DO > RY.
\end{align}
The last constraint is enough to prohibit impossible gene transfers as depicted
in Figure\nbsp{}[[fig-transfers]].

Sometimes, we do not know the exact donor branch but only that the donor branch
must be part of a known subtree. However, we usually do know the recipient
branch which is the stem of the subtree comprising the species which contain the
horizontally transferred gene. In this case, the ancestral node of the stem of
the donor subtree has to be older than the descending node of the recipient
branch.

#+caption: Direct, indirect and impossible horizontal gene transfers. A direct horizontal gene transfer happens between branches coexisting in time. An indirect horizontal gene transfer involves multiple events and an intermediate lineage. If the recipient branch is older than the donor branch, a horizontal gene transfer is impossible.
#+attr_latex: :width 1.0\textwidth :placement [tb]
#+name: fig-transfers
[[file:figures/transfers.svg]]

** Node braces
:PROPERTIES:
:ID:       d2814da0-2d21-41e5-9ded-bfaa47840d32
:END:
Finally, sometimes we know that two or more nodes have the same age or similar
ages. For example, when analyzing gene trees, an early gene duplication event
may separate the gene tree into two subtrees. Subsequent speciation events may
be observable on both subtrees, and the corresponding speciation nodes should
have similar ages. In this tutorial we will not brace nodes but see
Appendix\nbsp{}[[id:73cefaee-838c-451e-9dbc-a80b4b7123f4]] for the specifications.

* Pipeline
\mcmcdate{} is fast because it uses a clever way to approximate the phylogenetic
likelihood similar to MCMCTree [cite:@Yang2005]. MCMCTree approximates the
surface of the phylogenetic likelihood using Taylor expansion
[cite:@DosReis2011]. That is, a prior analysis computes the maximum likelihood
together with the gradient and the Hessian matrix which MCMCTree uses in a
subsequent analysis to date the tree.

Here, we use a similar technique, albeit with a Bayesian method to estimate the
posterior distribution of branch lengths measured in expected number
substitutions per site. In particular, the pipeline for dating a tree with
\mcmcdate{} is:
1. Prepare a multi sequence alignment and an unrooted topology.
2. For this alignment and unrooted topology, infer a distribution of unrooted
   trees with branch lengths measured in expected number of substitutions per
   site.
3. Find a rooted topology to date. Prepare auxiliary data such as node age
   calibrations or node order constraints.
4. Date the topology with \mcmcdate{}. In particular, infer a distribution of
   rooted trees with branch lengths measured in absolute time units. If the node
   age calibrations are insufficient, we can still use relative time units.
Steps 3 and 4 are fast, especially when compared to Step 2. Hence, we can
conveniently amend parameters used in the actual dating analysis, or compute
dated trees for different roots. The following section shows an example analysis
and describes the steps of the pipeline in detail.

* Example analysis
** Step 1: Alignment and unrooted topology
We are going to date a topology of eukaryotes [cite:@Strassert2021]. The full
published data set contains three alignments:
1. The alignment with the highest number of taxa comprises 733 eukaryotes with
   62723 amino acids.
2. The authors used the first alignment to infer a tree with IQ-TREE
   [cite:@Minh2020a] so they can filter taxa in an informed way (for example, to
   keep slow evolving taxa). The reduced data set comprises 136 operational
   taxonomic units with 73460 amino acids.
3. A small data set with 63 operational taxonomic units and 73460 amino acids
   for tree inference with Bayesian models.
Here, we focus on the second alignment with 136 taxa. We use shorter taxon names
and I have converted the file from FASTA format to Phylip format which is
required by Phylobayes [cite:@Lartillot2013]. I provide the alignment
=strassert-136taxa.phy= in the [[https://github.com/dschrempf/mcmc-date/tree/master/tutorial/data][data subfolder]] of this tutorial:

#+name: step1-alignment
#+begin_src sh :exports results :results output :wrap "src text"
ls data/*.phy
#+end_src

#+results: step1-alignment
#+begin_src text
data/strassert-136taxa.phy
#+end_src

\noindent For the phylogenetic inference in the next step, we also need an
unrooted topology. I have removed root of the tree in Figure 3 in
[cite/t:@Strassert2021]. Similar to the alignment, I provide the unrooted
topology in the [[https://github.com/dschrempf/mcmc-date/tree/master/tutorial/data][data subfolder]] of this tutorial:

#+name: step1-unrooted-topology
#+begin_src sh :exports results :results output :wrap "src text"
ls data/*unrooted*
#+end_src

#+results: step1-unrooted-topology
#+begin_src text
data/strassert-136taxa.unrooted.tre
#+end_src

\noindent Please also see the [[https://github.com/dschrempf/mcmc-date/blob/master/tutorial/data][README specifying the license and availability]] of
the data.

** Step 2: Phylogenetic inference
:PROPERTIES:
:ID:       784b898f-11f6-433e-bb8a-9584f377c8ce
:END:
Here, we use a Bayesian method to estimate the posterior distribution. In
particular, we will use Phylobayes [cite:@Lartillot2013], which you need to
install (either the [[https://github.com/bayesiancook/phylobayes][sequential]] and [[https://github.com/bayesiancook/pbmpi][parallel]] version). In this step, we have to
decide on an evolutionary model. The optimal evolutionary model is determined by
the nature (for example, the time range between most recent common ancestor and
the leaves of the tree) and the size of the data set (that is, number of rows
and columns in the alignment) which is an indicator for the computational
requirements.

We identify evolutionary models using their exchangeabilities and possibly their
across-site compositional heterogeneity [cite:e.g., @Koshi1995] and rate
heterogeneity [cite:e.g., @Yang1993] models. One major advantage of \mcmcdate{}
is the possibility to date trees with complex evolutionary models to infer the
branch lengths measured in expected number of substitutions per site. In
particular, we can use models accounting for across-site compositional
heterogeneity which is important when dating trees over long evolutionary time
scales [cite:see, e.g., @Szantho2022]. For example, the evolutionary model
=GTR+CAT+G4= uses general time reversible exchangeabilities [cite:GTR,
@Tavare1986], the Bayesian CAT model [cite:@Lartillot2004] to account for
across-site compositional heterogeneity, and the gamma rate model
[cite:@Yang1993] with four components to account for across-site rate
heterogeneity.

In general, I recommend the following evolutionary models sorted from preferred
but more complex to fast but simpler: =GTR+CAT+G4=, =LG+CAT+G4= [cite:LG:
@Le2008a], =LG+EDM64+G4= [cite: EDM: @Schrempf2020a], =LG+C60+G4= [cite: C60:
@Quang2008], and =LG+G4=. Phylobayes usually takes a long time to run, and I
recommend using a dedicated environment such as a scientific cluster. Here, we
will use the =LG+G4= model and the following [[https://github.com/dschrempf/mcmc-date/blob/master/tutorial/data/1-phylobayes.sh][script]]:
#+name: step2-phylobayes
#+begin_src sh :exports both :wrap "src sh" :results output
cat data/step2-phylobayes
#+end_src

#+results: step2-phylobayes
#+begin_src sh
#!/usr/bin/env sh
export afn=strassert-136taxa.phy
export tfn=strassert-136taxa.unrooted.tre
export md=lg

pb -d $afn -T $tfn -ncat 1 -$md -dgam 4 -x 10 10000 "${afn}_${tfn}_${md}+g4"
#+end_src

Phylobayes (or any other Bayesian phylogenetic software package) samples a
posterior distribution of trees, which is the input to \mcmcdate{}. I provide
the corresponding tree list file for this analysis in the [[https://github.com/dschrempf/mcmc-date/tree/master/tutorial/data][data directory]]:
#+name: step2-treelist
#+begin_src sh :exports both :results output :wrap "src text"
head -n 3 data/strassert-136taxa-lg+g4.treelist | sed -E "s/(.{80}).*$/\1.../"
echo "..."
#+end_src

#+results: step2-treelist
#+begin_src text
(((((((((((((((((Al_Alexand:0.0416858,Al_Neocera:0.0751388):0.125206,(Al_Crypthe...
(((((((((((((((((Al_Alexand:0.0660346,Al_Neocera:0.0987786):0.0313159,(Al_Crypth...
(((((((((((((((((Al_Alexand:0.0654659,Al_Neocera:0.0983142):0.0284921,(Al_Crypth...
...
#+end_src

** Step 3: Rooted topology and auxiliary data
:PROPERTIES:
:ID:       54c61d87-6dbf-48e2-a43e-e788acb0b18f
:END:
[cite/t:@Strassert2021] discuss one unrooted topology with two possible root
positions. (1) The root separates amorphea from diaphoretickes and excavates
[cite: Figure 3 in @Strassert2021], and (2) the root separates amorphea and
excavates from diaphoretickes. Here, we choose option (1) because this tree also
appears in the main text. In general, \mcmcdate{} is fast enough to allow
analysis and comparison of more root positions. Further, we use auxiliary data
from 33 fossil calibrations compiled by [cite/t:@Strassert2021]. Finally, the
discussed order of endosymbiosis events enforce a set of node order constraints.
Here, we use the hypothesis of [cite/t:@Stiller2014], and direct transfers as
discussed in Section\nbsp{}[[id:59c21f15-25f3-4e0f-be18-0e94e83a2ac8]].

I provide the rooted tree, the node age calibration file in Newick tree format
(Appendix\nbsp{}[[id:28e89719-7885-45c7-ad93-eecd85c4d849]]), and the node order
constraint file in CSV format
(Appendix\nbsp{}[[id:724cf63d-f058-408a-b01c-e4b97ee6036a]]) in the [[https://github.com/dschrempf/mcmc-date/tree/master/tutorial/data][data directory]].

** Step 4: Dating with \mcmcdate{}
\mcmcdate{} is a Haskell program.
Appendix\nbsp{}[[id:a38b78be-7ee6-4340-946a-2a5d06385b66]] provides details about
the internals. Here, we will use a wrapper script characteristicly named =run=.

\appendix

** Optional: Marginal likelihood calculation

* Auxiliary data specifications
:PROPERTIES:
:ID:       202fc129-8d65-4966-a217-322231ff9c49
:END:
The specifications match \mcmcdate{} version 1.0.0.0 and may change between
different versions of \mcmcdate{}.

** Node age calibrations
:PROPERTIES:
:ID:       28e89719-7885-45c7-ad93-eecd85c4d849
:END:
Node age calibrations can be provided in two ways:
- with comma separated value (CSV) files, or
- with Newick tree files (MCMCTree specification; see the documentation of
  MCMCTree; only L, U, and B are supported).
If the filename ends with =csv=, assume the calibrations are provided in CSV
format. Otherwise, assume the calibrations are provided on a Newick tree. The
CSV file has a header (see below), and one or more rows of the following format:
#+begin_src text :exports code
Name,LeafA,LeafB,YoungAge,YoungProbabilityMass,OldAge,OldProbabilityMass
#+end_src
In this case, the calibrated node is uniquely defined as the most recent common
ancestor of =LeafA= and =LeafB=. The age of the node is calibrated between the
lower (young) and upper (old) boundary. The probability mass describes the
softness (or hardness) of a boundary. In other words, the probability mass
describes the steepness of the decline of the prior function outside the
calibration interval. In general, the larger the probability mass the softer the
boundary. We specify probability masses with respect to a normalized time
interval of size \(1.0\). That is, probability masses have to be strictly
positive and strictly less than \(1.0\), which is the total probability mass in
the unit interval.

A case study: Assume the root has an age of \(4.5\;\text{Gya}\). Then, the
complete time interval from present (\(0\;\text{Gya}\)) to the position of the
root has a probability mass of \(1.0\). In this case, a probability mass value
of \num{1e-4} roughly corresponds to a time interval of \(4.5\;\text{Gy} \cdot
\num{1e-4} = 0.45\;\text{My}\). However, we attach halves of normal
distributions to the uniform node age calibration intervals, and so the prior
function at this specific boundary will decline to small values (a bit) faster
than within \(0.45\;\text{My}\). Of note, if the root is younger, for example,
at \(2.5\;\text{Gya}\), then a value of \num{1e-4} is stricter in terms of
absolute time units, and roughly corresponds to an interval of
\(0.25\;\text{My}\).

I usually use values between \num{1e-4} (hard) and \num{3e-2} (soft). If unsure,
use probability masses of \num{2.5e-2}, which corresponds to \(2.5\) percent
probability at each boundary or constraint. A probability mass close to \(1.0\)
will correspond to a prior function too soft to have any effect. Note that this
way of specifying boundary softness using relative values independent of the
actual node ages differs from MCMCTree which uses absolute values
[cite:@Yang2005]. When using a Newick tree to specify node age calibrations, and
when no probability masses are provided, a default value of \num{1e-2} is used.
This measure is in place to support the same input files as MCMCTree.

To specify one-sided node age calibrations, omit the other boundary and the
corresponding probability mass. For example, the following file defines a node
age calibration with a lower boundary at \num{1e6} time units (years in this
case) with probability mass \num{2.5e-2}:
#+begin_src text :exports code
Name,LeafA,LeafB,YoungAge,YoungProbabilityMass,OldAge,OldProbabilityMass
Primates,Human,Chimpanzees,1e6,2.5e-2,,
#+end_src

** Node order constraints
:PROPERTIES:
:ID:       724cf63d-f058-408a-b01c-e4b97ee6036a
:END:
Node order constraints are provided using a comma separated value (CSV) file
with a header (see below) and one ore more rows of the following format:
#+begin_src text :exports code
Name,YoungerLeafA,YoungerLeafB,OlderLeafA,OlderLeafB,ProbabilityMass
#+end_src
The younger and older nodes are uniquely defined as the most recent common
ancestors of =YoungerLeafA= and =YoungerLeafB=, as well as =OlderLeafA= and
=OlderLeafB=, respectively. As described in the previous section about node age
calibrations, the probability mass describes the softness (or hardness) of the
constraint. For example, the following file defines a constraint where the
ancestor of leaves =A= and =B= is younger than the ancestor of leaves =C= and
=D=:
#+begin_src text :exports code
Name,YoungerLeafA,YoungerLeafB,OlderLeafA,OlderLeafB,ProbabilityMass
ExampleConstraint,A,B,C,D,0.025
#+end_src
\mcmcdate{} reports and removes redundant constraints such as constraints
affecting nodes that are vertically related.

** Node braces
:PROPERTIES:
:ID:       73cefaee-838c-451e-9dbc-a80b4b7123f4
:END:
Node braces are provided using files in JavaScript object notation (JSON)
format. Similar to node age calibrations and node order constraints, the braced
nodes are specified using pairs of leaves. However, the softness (or hardness)
of braces is defined in a different way. The reason is that more than two nodes
can be braced, and so, there is no canonical way to describe the softness using
probability mass. Rather, for a specific node brace, the differences between the
node ages and the average age of all nodes in the particular node brace are
normally distributed with the provided standard deviation.

The following example defines two node braces constraining two and three nodes,
respectively:
#+begin_src json
[
  {
    "braceDataName": "Brace1",
    "braceDataNodes": [
      [
        "NodeXLeafA",
        "NodeXLeafB"
      ],
      [
        "NodeYLeafA",
        "NodeYLeafB"
      ]
    ],
    "braceDataStandardDeviation": 0.0001
  },
  {
    "braceDataName": "Brace2",
    "braceDataNodes": [
      [
        "NodeALeafA",
        "NodeALeafB"
      ],
      [
        "NodeBLeafA",
        "NodeBLeafB"
      ],
      [
        "NodeCLeafA",
        "NodeCLeafB"
      ]
    ],
    "braceDataStandardDeviation": 0.0001
  }
]
#+end_src
In this case, the braced nodes of the first node brace are uniquely defined as
the most recent common ancestors of =NodeXLeafA= and =NodeXLeafB=, as well as
=NodeYLeafA= and =NodeYLeafB=. The steepness of the brace prior function is
defined using the standard deviation. This file defines hard node braces.

* Internals
:PROPERTIES:
:ID:       a38b78be-7ee6-4340-946a-2a5d06385b66
:END:
I have written \mcmcdate{} in Haskell. The Haskell programming language is
versatile, interesting, and leads to more maintainable code with fewer bugs when
compared to other programming languages. Nevertheless, the tooling support is
sometimes sub-optimal. Before running \mcmcdate{} you need to compile the
Haskell code. In most cases, the [[https://github.com/dschrempf/mcmc-date/blob/master/scripts/run][wrapper script called =run=]], which is used in
this tutorial, does this for you in a reproducible way, and so there is no need
for manual action. Sometimes, however, manual action may be required.

In this case, you need a rough understanding of the tools involved. There are
two build tools commonly used with Haskell: =cabal-install=, and =Stack= with
binaries =cabal=, and =stack=, respectively. I recommend using =cabal-install=,
and the wrapper script uses =cabal-install= by default. If you want to use
=Stack=, use the option =-s= like so: =run -s ...=. See also the output of =run
-h=. In rare occasions you may want to clean your local build cache. You can do
this by running =cabal clean= or =stack clean=; or more strictly, by deleting
the =dist-newstyle= or =.stack-work= directories in you working directories for
=cabal-install= and =Stack=, respectively.

** Wrapper script
The wrapper script =run= tries to make a good compromise between usability and
customizability. It exposes some, but not all functionality of \mcmcdate{}:
#+name: wrapper-script
#+begin_src sh :exports both results :results output :wrap "src text"
run -h
#+end_src

#+results: wrapper-script
#+begin_src text
Usage: run [OPTIONS] RELAXED_MOLECULAR_CLOCK_MODEL LIKELIHOOD_SPECIFICATION COMMANDS

Prior options:
-b Activate braces
-c Activate calibrations
-k Activate constraints

Algorithm related options:
-i NAME  Initialize state and cycle from previous analysis with NAME
-H       Activate Hamiltonian proposal (slow, but great convergence)
-m       Use Mc3 algorithm insteahd of Mhg

Other options:
-f FILE    Use a different analysis configuration file (relative path)
-n SUFFIX  Use an analysis suffix
-p         Activate profiling
-s         Use Haskell stack instead of cabal-install

Relaxed molecular clock model:
ug  Uncorrelated gamma model
ul  Uncorrelated log normal model
al  Autocorrelated log normal model

Likelihood specification:
f  Full covariance matix
s  Sparse covariance matrix
u  Univariate approach
n  No likelihood; use prior only

Available commands:
p  Prepare analysis
r  Run dating analysis
c  Continue dating analysis
m  Compute marginal likelihood

A configuration file "analysis.conf" is required.
For reference, see the sample configuration file.
#+end_src
If you need to adjust specific parameters or settings, you can (a) call the
\mcmcdate{} executable directly, and, if this is not enough, (b) directly change
parameters or functions in the code. In the following, I briefly explain both
options.

** Direct invocation of \mcmcdate{}
Use the build tool of your choice (see above) to directly run \mcmcdate{}. For
example, with =cabal-install=:
#+name: direct-invocation
#+begin_src sh :exports both :results output :wrap "src text"
cabal run mcmc-date-run -- -h
#+end_src

#+results: direct-invocation
#+begin_src text
Up to date
mcmc-date; version 1.0.0.0

Usage: mcmc-date-run COMMAND

  Date a phylogenetic tree using calibrations and constraints

Available options:
  -h,--help                Show this help text

Available commands:
  prepare                  Prepare data
  run                      Run MCMC sampler
  continue                 Continue MCMC sampler
  marginal-likelihood      Calculate marginal likelihood
#+end_src

\noindent The help shows that \mcmcdate{} exposes four sub-commands. For
example, to get help about how to run a new analysis:
#+name: run-analysis
#+begin_src sh :exports both :results output :wrap "src text"
cabal run mcmc-date-run -- run -h
#+end_src

\noindent Hence, an example command line is:
#+name: example-run
#+begin_src sh :exports code
cabal run -- mcmc-date-run run \
  --analysis-name example \
  --calibrations "csv calibrations.csv" \
  --constraints "constraints.csv" \
  --relaxed-molecular-clock "UncorrelatedLogNormal" \
  --likelihood-spec "SparseMultivariateNormal 0.1"
#+end_src

\noindent Get help about how to continue an analysis with:
#+name: continue-analysis
#+begin_src sh :exports code :results output :wrap "src text"
cabal run mcmc-date-run -- continue -h
#+end_src

\noindent Consequently, continue the above example analysis with:
#+name: example-continue
#+begin_src sh :exports code
cabal run -- mcmc-date-run continue \
  --analysis-name example \
  --calibrations "csv calibrations.csv" \
  --constraints "constraints.csv" \
  --relaxed-molecular-clock "UncorrelatedLogNormal" \
  --likelihood-spec "SparseMultivariateNormal 0.1"
#+end_src

The commands are verbose. In my experience, detailed specification of the
parameters and settings on the command line involves more investment in the
beginning, but reduces the number of bogus analyses in the end.

** Understanding the Haskell code
:PROPERTIES:
:ID:       0d0620bf-1fc4-484c-b7b4-d6ffffe0b357
:END:
At the core of \mcmcdate{} are two libraries I have authored: [[https://hackage.haskell.org/package/mcmc][mcmc]], a general
purpose Markov chain Monte Carlo (MCMC) sampler with advanced algorithms; and
[[https://hackage.haskell.org/package/elynx-tree][elynx-tree]], a library for handling trees.

Additionally, I have separated \mcmcdate{} into two parts. Part (a) is the
executable =mcmc-date-run= with modules specifying the state space, the prior
and likelihood functions, the proposals, and MCMC-specific settings such as the
number of burn-in and normal iterations. These modules are in the subfolder
[[https://github.com/dschrempf/mcmc-date/tree/master/app][=app=]] of the \mcmcdate{} repository. Part (b) is a library containing prior
functions and proposals specific to phylogenetic trees. I will not provide
details for the library part here, but feel free to contact me for specific
questions if you want. In general, you can access detailed help by rendering and
opening the documentation directly contained in the source files:

#+name: McmcHaddock
#+begin_src sh :exports both :results output :wrap "src text"
cabal haddock mcmc-date
#+end_src

#+results: McmcHaddock
#+begin_src text
Build profile: -w ghc-9.2.4 -O1
In order, the following will be built (use -v for more details):
 - mcmc-date-1.0.0.0 (lib) (ephemeral targets)
Preprocessing library for mcmc-date-1.0.0.0..
Running Haddock on library for mcmc-date-1.0.0.0..
 100% (  4 /  4) in 'Mcmc.Tree.Import'
 100% ( 16 / 16) in 'Mcmc.Tree.Types'
 100% (  2 /  2) in 'Mcmc.Tree.Prior.Branch'
 100% ( 10 / 10) in 'Mcmc.Tree.Prior.Branch.RelaxedClock'
 100% (  6 /  6) in 'Mcmc.Tree.Prior.BirthDeath'
 100% (  3 /  3) in 'Mcmc.Tree.Monitor'
 100% ( 11 / 11) in 'Mcmc.Tree.Lens'
 100% ( 18 / 18) in 'Mcmc.Tree.Prior.Node.Constraint'
 100% ( 20 / 20) in 'Mcmc.Tree.Prior.Node.Calibration'
 100% (  2 /  2) in 'Mcmc.Tree.Prior.Node.CalibrationFromTree'
 100% ( 12 / 12) in 'Mcmc.Tree.Prior.Node.Brace'
 100% (  2 /  2) in 'Mcmc.Tree.Prior.Node.Combined'
 100% ( 12 / 12) in 'Mcmc.Tree.Proposal.Unconstrained'
 100% (  7 /  7) in 'Mcmc.Tree.Proposal.Ultrametric'
 100% (  7 /  7) in 'Mcmc.Tree.Proposal.Contrary'
 100% (  3 /  3) in 'Mcmc.Tree.Proposal.Brace'
 100% ( 22 / 22) in 'Mcmc.Tree'
Documentation created:
/home/dominik/Shared/haskell/mcmc-date/dist-newstyle/build/x86_64-linux/ghc-9.2.4/...
#+end_src
In my case, the documentation in HTML format is then available at
: ${SUBTITUTE_ABOVE_PATH}/mcmc-date-1.0.0.0/doc/html/mcmc-date/index.html
\noindent which, I am sure, you can remember easily. Did I already say that
Haskell tooling has room for improvements?

\noindent Now, back to the application part (a), which will most likely be more
important for you. In particular, you may want to have a look at the modules
- [[https://github.com/dschrempf/mcmc-date/blob/master/app/Definitions.hs][Definitions]] :: Contains proposals and monitors, as well as MCMC-specific
  settings. If you want to change the number of burn-in iterations, or the
  number of total iterations, have a look and change this file.
- [[https://github.com/dschrempf/mcmc-date/blob/master/app/State.hs][State]] :: Defines the state space. If you really want to understand what is
  going on, this should be your starting point. The documentation is detailed,
  and explains the separation of the time tree and rate tree objects, as well as
  the birth and death prior.

\noindent The other more important modules are:
- Main :: Contains functions to prepare the data, as well as to run and continue
  the analysis. This module also contains helper functions to calculate the
  marginal likelihood.
- Probability :: Defines the prior and likelihood functions. This module is
  important, if you want to tweak the prior.

\noindent The less important modules are:
- Hamiltonian :: Hamiltonian proposal.
- Monitor :: Prior specific monitoring functions.
- Options :: Handle command line options.
- Tools :: Miscellaneous tools.

* References :ignore:
#+print_bibliography:

* Footnotes

[fn:1] We should probably say /dating the topology/ but this phrase is not used.
